Global functions and key bindings

** Custom Functions
#+BEGIN_SRC emacs-lisp
  (defun nxml-where ()
    "Display the hierarchy of XML elements the point is on as a path."
    (interactive)
    (let ((path nil))
      (save-excursion
        (save-restriction
          (widen)
          (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                      (condition-case nil
                          (progn
                            (nxml-backward-up-element) ; always returns nil
                            t)
                        (error nil)))
            (setq path (cons (xmltok-start-tag-local-name) path)))
          (if (called-interactively-p t)
              (message "/%s" (mapconcat 'identity path "/"))
            (format "/%s" (mapconcat 'identity path "/")))))))

  (defun redefine-faces-exotica ()
    (set-face-attribute 'cursor nil :background "#d1d")
    (set-face-attribute 'cursor nil :background "white")
    (set-face-attribute 'cursor nil :background "#d1d")
    (set-face-attribute 'fringe nil :foreground "spring green")
    (set-face-attribute 'vertical-border nil :foreground "#212")

    (set-face-attribute 'region nil :background "dark slate blue")
    (set-face-attribute 'hl-line nil :background "#224")
    (set-face-attribute 'show-paren-match nil
                        :background "dark slate blue"
                        :underline nil)
    (set-face-attribute 'mode-line nil
                        :background "dark slate blue"
                        :foreground "CadetBlue1"
                        :box '(:line-width 1 :color "#212"))
    (set-face-attribute 'mode-line-inactive nil
                        :background "#212"
                        :foreground "purple"
                        :box '(:line-width 1 :color "#212")))
  (defun gui-tweaks ()
    (interactive)
    (set-face-attribute 'default nil :height 110 :font "JetBrains Mono")
    (redefine-faces-exotica)
    (when tool-bar-mode
      (menu-bar-mode 0)
      (scroll-bar-mode 0)
      (tool-bar-mode 0)
      (tooltip-mode 0)))

  (defun my-suspend-frame ()
    "In a GUI environment, do nothing; otherwise `suspend-frame'."
    (interactive)
    (if (display-graphic-p)
        (message "suspend-frame disabled for graphical displays.")
      (suspend-frame)))

  (defun font-names-list ()
    "Get list of names of installed fonts,which can be used to set font."
    (seq-filter (lambda (font)
                  (when-let ((info (font-info font)))
                    (string-match-p "spacing=100" (aref info 1))))
                (font-family-list)))

  (defun me/prev-window ()
    "Other-window, backward"
    (interactive)
    (other-window -1))

  (defun zarkone/insert-current-date ()
    "Insert current date here."
    (interactive)
    (insert
     (shell-command-to-string "date")))

  (defun vertical-three-windows-layout ()
    "Vertical, three window layout"
    (interactive)
    (delete-other-windows)
    (split-window-horizontally)
    (split-window-horizontally)
    (balance-windows))

  (defun run-static-server (&optional on-random-port)
    "Run static server in current dir, with default port (8000).
      With prefix arg, run at random free port"
    (interactive "P")
    (let ((shell-command "python -m SimpleHTTPServer"))
      (async-shell-command
       (concat shell-command
               (when on-random-port
                 " 0")))))

  (defun emacs-reload ()
    "reloads emacs config"
    (interactive)
    (org-babel-load-file (expand-file-name "literally.org" user-emacs-directory)))

  (defun me/comment-or-uncomment-region-or-line ()
    "Comments or uncomments the region or the current line if there's no active region."
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)
      (next-line)))

  (defun me/switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (defun me/kill-region-or-backward-kill-word (&optional arg region)
    "`kill-region' if the region is active, otherwise `backward-kill-word'"
    (interactive
     (list (prefix-numeric-value current-prefix-arg) (use-region-p)))
    (if region
        (kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))

  (global-set-key (kbd "C-w") 'me/kill-region-or-backward-kill-word)

  (defun me/my-put-file-name-on-clipboard ()
    "Put the current file name on the clipboard"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (with-temp-buffer
          (insert filename)
          (clipboard-kill-region (point-min) (point-max)))
        (message filename))))

  (defun me/duplicate-line ()
    "Duplicate current line."
    (interactive)
    (move-beginning-of-line 1)
    (kill-line)
    (yank)
    (open-line 1)
    (next-line 1)
    (yank))

  (defun me/kill-till-end ()
    "Deletes everything from point to end of file"
    (interactive)
    (delete-region
     (point)
     (point-max)))

  (defun delete-whitespace (&optional backward-only)
    "Delete all spaces, tabs and newlinesaround point.
      If BACKWARD-ONLY is non-nil, only delete them before point."
    (interactive "*P")
    (let ((orig-pos (point)))
      (delete-region
       (if backward-only
           orig-pos
         (progn
           (skip-chars-forward " \t\n")
           (constrain-to-field nil orig-pos t)))
       (progn
         (skip-chars-backward " \t\n")
         (constrain-to-field nil orig-pos)))))

  (defun bf-pretty-print-xml-region (begin end)
    "Pretty format XML markup in region. You need to have nxml-mode
  http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
  this.  The function inserts linebreaks to separate tags that have
  nothing but whitespace between them.  It then indents the markup
  by using nxml's indentation rules."
    (interactive "r")
    (save-excursion
      (nxml-mode)
      (goto-char begin)
      (while (search-forward-regexp "\>[ \\t]*\<" nil t)
        (backward-char) (insert "\n"))
      (indent-region begin end)))

  (defun zarkone/pretty-print-xml-buffer ()
    (interactive)
    (bf-pretty-print-xml-region (point-min) (point-max)))
#+END_SRC

** Custom KBD Macro
Removed all macroses to functions ATM; decided to leave =defkbdmacro= here for
future reference.
#+BEGIN_SRC emacs-lisp
  (defmacro defkbdmacro (name keyseq-string &optional docstring)
    `(fset (quote ,name)
           (lambda (&optional arg)
             ,docstring
             (interactive "p")
             (kmacro-exec-ring-item (quote (,keyseq-string 0 "%d")) arg))))
#+END_SRC
** Global vars, hooks and key bindings
#+BEGIN_SRC emacs-lisp
  (use-package use-package-chords
    :demand t
    :config (key-chord-mode 1))

  (use-package emacs
    :hook ((before-save . delete-trailing-whitespace)
           (emacs-lisp-mode . enable-paredit-mode)
           (org-mode . auto-fill-mode)
           (org-mode . flyspell-mode))
    :custom
    (auth-sources '((:source "/home/zarkone/.emacs.d/secrets/.authinfo.gpg")))
    (safe-local-variable-values '((url-max-redirections . 0)))
    (dired-listing-switches "-alGh")
    (indent-tabs-mode nil)
    (truncate-lines t)
    (word-wrap nil)
    (select-enable-clipboard t)
    (select-enable-primary nil)
    (uniquify-buffer-name-style 'forward)
    (save-interprogram-paste-before-kill t)
    (compilation-always-kill  t)
    (apropos-do-all t)
    (mouse-yank-at-point t)
    (save-place-file (concat user-emacs-directory ".places"))
    (backup-directory-alist `(("." . ,(concat user-emacs-directory ".backups"))))
    (warning-suppress-types '((comp)))
    (default-input-method 'russian-computer)
    (browse-url-browser-function 'browse-url-firefox)
    (safe-local-variable-values '((eval define-clojure-indent
                                        (reg-cofx :defn)
                                        (reg-event-db :defn)
                                        (reg-event-fx :defn)
                                        (reg-fx :defn)
                                        (reg-sub :defn)
                                        (reg-event-domain :defn)
                                        (reg-block-event-fx :defn)
                                        (reg-event-domain-fx :defn)
                                        (this-as 0))
                                  (url-max-redirections . 0)) nil nil "Customized with use-package emacs")
    :init
    (show-paren-mode 1)
    (menu-bar-mode 0)
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t)

    :config
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'downcase-region 'disabled nil)
    (global-unset-key (kbd "M-ESC ESC"))
    (global-unset-key (kbd "C-z"))

    :chords (("k[" . delete-whitespace)
             ("3r" . replace-regexp)
             ("jk" . save-buffer)
             ("i0" . me/switch-to-previous-buffer)
             ("[]" . "[]\C-b")
             ("<>" . "<>\C-b")
             ("''" . "''\C-b")
             ("\"\"" . "\"\"\C-b")
             ("()" . "()\C-b")
             ("{}" . "{}\C-b"))

    :bind (("C-x M-5" . delete-other-windows-vertically)
           ("C-z 3" . vertical-three-windows-layout)
           ("C-z C-d" . delete-other-windows)
           ("C-z C-s" . split-window-below)
           ("C-z C-r" . split-window-right)
           ("C-z C-z" . my-suspend-frame)
           ("C-z C-n" . me/switch-to-previous-buffer)
           ("C-_" . upcase-word)
           ("C-x C-d" . dired-jump)
           ("C-c M-o" . occur)
           ("<C-return>" . save-buffer)
           ("C-x M-o" . helm-occur)
           ("M-o" . other-window)
           ("C-x RET RET" . compile)
           ("C-x M-m" . recompile)
           ("C-M-;" . replace-regexp)
           ("C-x H" . help)
           ("C-c M-." . zarkone/insert-current-date)
           ("C-x C-g" . goto-address-at-point)
           ("M-/" . hippie-expand)
           ("M--" . delete-whitespace)
           ("C-x C-k DEL" . me/kill-till-end)
           ("C-M-y" . me/duplicate-line)
           ("C-x M-w" . me/my-put-file-name-on-clipboard)
           ("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp)
           ("C-x M-v" . visual-line-mode)
           ("C-c p" . windmove-up)
           ("C-c n" . windmove-down)
           ("C-c b" . windmove-left)
           ("C-c f" . windmove-right)
           ("C-<backspace>" . undo)

           :map prog-mode-map
           ("C-M-c" . me/comment-or-uncomment-region-or-line)

           ;; :map nxml-mode-map
           ;; ("M-." . zarkone/pretty-print-xml-buffer)
           ;; ("M-," . nxml-where)
           )
    )

  ;; Enable vertico
  (use-package vertico
    :init
    (vertico-mode)

    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    ;; (setq vertico-count 20)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    ;; (setq vertico-cycle t)
    )

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode))

  ;; Optionally use the `orderless' completion style.
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
  ;; A few more useful configurations...

  (use-package marginalia
    ;; Either bind `marginalia-cycle' globally or only in the minibuffer
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-z M-t" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-z C-b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-z C-t" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key (kbd "M-.")
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (the default)
    ;; (setq consult-project-function #'consult--default-project--function)
    ;;;; 2. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
  )



#+END_SRC
* Appearance
** OSX
   #+begin_src emacs-lisp
     (use-package osx-pseudo-daemon
       :custom
       (osx-pseudo-daemon-mode 1)
       (mac-option-modifier 'super)
       (mac-command-modifier 'meta))

     (use-package exec-path-from-shell
       :init
       (when (memq window-system '(mac ns x))
         (exec-path-from-shell-initialize)))
   #+end_src
** Disable all GUI
#+BEGIN_SRC emacs-lisp
  (when window-system
    (menu-bar-mode 0)
    (scroll-bar-mode 0)
    (tool-bar-mode 0)
    (tooltip-mode 0))

  (global-hl-line-mode 1)
  (blink-cursor-mode 1)

  (setq ring-bell-function 'ignore)
  (setq-default indicate-buffer-boundaries 'left)
  (use-package diminish)
#+END_SRC
** Set window title in TERM
   #+begin_src emacs-lisp
     (setq-default frame-title-format '("Emacs: %b"))

     (add-hook 'after-make-frame-functions
               (lambda (frame)
                 (nyan-mode 1)
                 (gui-tweaks)
                 ))

   #+end_src
** Highlight git changes in fringes
   #+begin_src emacs-lisp
     (use-package diff-hl
       :hook (after-init . global-diff-hl-mode))
   #+end_src
** Ligatures
#+begin_src emacs-lisp
  (load-file "~/.emacs.d/ligature.el/ligature.el")

  (use-package ligature
    :ensure nil
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                         ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                         "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                         "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                         "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                         "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                         "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                         "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                         ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                         "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                         "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                         "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                         "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+end_src
** Color Theme
#+BEGIN_SRC emacs-lisp
  (setq custom-safe-themes t)

  (use-package exotica-theme
    :init (load-theme 'exotica t)
    :config
    (gui-tweaks))

  ;; (use-package ef-themes
  ;;   :init (load-theme 'ef-winter t)
  ;;   :config
  ;;   (gui-tweaks)
  ;;   )


  ;; (use-package phoenix-dark-mono-theme
  ;;   :init (load-theme 'phoenix-dark-mono t)
  ;;   :config
  ;;   (gui-tweaks))

  ;; (use-package modus-operandi-theme
  ;;   :init (load-theme 'modus-operandi t)
  ;;   :config
  ;;   (gui-tweaks))

  ;; (use-package modus-vivendi-theme
  ;;   :init (load-theme 'modus-vivendi t)
  ;;   :config
  ;;   (gui-tweaks))
#+END_SRC
* Packages
** nyan-cat
   #+begin_src emacs-lisp
     (use-package nyan-mode
       :config
       (nyan-mode))
   #+end_src
** langtool
   #+begin_src emacs-lisp
     (use-package langtool
       :custom
       (langtool-language-tool-server-jar "/home/zarkone/Downloads/LanguageTool-5.1/languagetool-server.jar"))
   #+end_src
** nix
#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :hook ((nix-mode . lsp)))

#+END_SRC

** browse-at-remote
#+begin_src emacs-lisp
  (defun yank-remote-and-msg ()
    (interactive)
    (message (bar-to-clipboard)))

  (use-package browse-at-remote
    :bind (("C-x M-e" . browse-at-remote)
           ("C-x M-r" . yank-remote-and-msg)))
#+end_src
** fish
#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :hook ((before-save . fish_indent-before-save)))
#+END_SRC

** COMMENT company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish ""
    :hook ((prog-mode . company-mode))
    :config
    (push 'company-elisp company-backends))
#+END_SRC
** expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C-x x" . er/expand-region)))
#+END_SRC
** git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :bind (("C-x G" . git-timemachine)))
#+END_SRC
** COMMENT helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :diminish ""
    :commands helm
    :hook (after-init . helm-mode)
    :custom
    (helm-buffers-fuzzy-matching t)
    (helm-recentf-fuzzy-match t)
    (helm-M-x-fuzzy-match t)
    :bind (("C-z M-t" . helm-mini)
           ("C-x C-f" . helm-find-files)
           ("M-x" . helm-M-x)
           ("M-y" . helm-show-kill-ring)
           ("C-M-h" . me/kill-region-or-backward-kill-word)
           ("C-c M-o" . helm-occur)
           ("C-x C-r" . helm-recentf)
           :map helm-map
           ("C-i" . helm-execute-persistent-action)))

#+END_SRC
*** TODO helm-cd-path
    implement (or find) helm autocomplete for dirs from ~$CDPATH~
*** COMMENT helm plugins
#+BEGIN_SRC emacs-lisp
  (use-package helm-company)

  (use-package counsel
    :custom
    (ivy-height 15)
    :bind (("C-x C-p" . counsel-rg)))

  (defun zarkone/helm-do-grep-ag ()
    (interactive)
    (helm-grep-ag
     (expand-file-name (vc-find-root default-directory ".git")) nil))

  (use-package helm-ag
    :bind (("C-z C-t" . helm-projectile))
    :custom
    (helm-grep-ag-command (concat "rg"
                                  " --color=never"
                                  " --smart-case"
                                  " --no-heading"
                                  " --line-number %s %s %s"))
    (helm-grep-file-path-style 'relative)
    (helm-projectile-set-input-automatically nil))
  (use-package helm-projectile
    :bind (("C-x C-b" . helm-projectile-switch-to-buffer)))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("C-z C-g" . magit-status)))
#+END_SRC
** paredit
   #+begin_src emacs-lisp
     (use-package paredit
       :diminish ""
       :commands (enable-paredit-mode))
   #+end_src
** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish ""
    :demand t
    :after (helm)
    :hook (after-init . projectile-global-mode)
    :bind-keymap (("C-c C-p" . projectile-command-map))
    :custom
    (projectile-completion-system 'helm)
    (projectile-mode-line " P"))
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :hook (after-init . yas-global-mode))
#+END_SRC
** yaml
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indentation)
  (use-package smart-shift)
  (use-package yaml-mode
    :custom
    (yaml-indent-offset 2)
    :hook ((yaml-mode . highlight-indentation-mode)
           (yaml-mode . smart-shift-mode)))
#+END_SRC

** restclient
#+BEGIN_SRC emacs-lisp
  (use-package restclient)
#+END_SRC
** gnus
#+begin_src emacs-lisp
  (setq gnus-select-method
   '(nnmaildir "pitch"
               (directory "~/.nnmaildir/Pitch")))

  (setq gnus-secondary-select-methods
        '((nnmaildir "pitch"
                     (directory "~/.nnmaildir/Pitch"))
          (nnmaildir "zarkonesmall"
                     (directory "~/.nnmaildir/Gmail"))))

#+end_src
** mu4e
#+BEGIN_SRC emacs-lisp
  ;; Installed mu via nixos; it automatically adds it to load path.
  ;; But still need to require it manually.
  (require 'mu4e)

  (setq mu4e-maildir-shortcuts
        '((:maildir "/sent"             :key  ?s)
          (:maildir "/Gmail/INBOX"      :key  ?z)
          (:maildir "/Pitch/INBOX"      :key  ?p)))

  (setq mu4e-pitch-signature
        (format "<#part type=text/html><html><body><p>%s</p></body></html><#/part>"
                (with-temp-buffer
                  (insert-file-contents "~/.emacs.d/pitch-signature.html")
                  (buffer-string))))

  (setq mu4e-contexts
        `( ,(make-mu4e-context
             :name "Zarkonesmall"
             :enter-func (lambda () (mu4e-message "Entering Zarkonesmall context"))
             :match-func
             (lambda (msg)
               (when msg
                 (string-match-p "^/Gmail" (mu4e-message-field msg :maildir))))

             :vars '((user-mail-address . "zarkonesmall@gmail.com")
                     (smtpmail-smtp-user . "zarkonesmall@gmail.com")
                     (user-full-name . "Anatolii Smolianinov")
                     (mu4e-compose-signature . "Anatolii Smolianinov")))
           ,(make-mu4e-context
             :name "Pitch"
             :enter-func (lambda () (mu4e-message "Switch to the Pitch context"))
             ;; no leave-func
             ;; we match based on the maildir of the message
             ;; this matches maildir /Arkham and its sub-directories
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/Pitch" (mu4e-message-field msg :maildir))))
             :vars `((user-mail-address . "anatolii@pitch.io")
                     (smtpmail-smtp-user . "anatolii@pitch.io")
                     (user-full-name . "Anatolii Smolianinov")
                     ;; TODO: html signature  https://dataswamp.org/~solene/2016-06-07-13.html
                     (mu4e-compose-signature . ,mu4e-pitch-signature)
                     ))))

  ;; start with the first (default) context;
  ;; default is to ask-if-none (ask when there's no context yet, and none match)
  (setq mu4e-context-policy 'pick-first)
  (setq mu4e-bookmarks
        (add-to-list 'mu4e-bookmarks
                     '(:name  "Flagged messages"
                       :query "flag:flagged"
                       :key ?f)))
  (setq mu4e-bookmarks
        (add-to-list 'mu4e-bookmarks
                     '(:name  "Pitch Github Last Week"
                       :query "list:pitch-app.pitch-io.github.com and date:7d..now"
                       :key ?g)))

  (use-package mu4e
    :ensure nil
    :custom
    (mu4e-hide-index-messages t)
    (mu4e-update-interval nil)
    (message-kill-buffer-on-exit t)
    (message-send-mail-function 'smtpmail-send-it)
    (smtpmail-default-smtp-server "smtp.gmail.com")
    (smtpmail-smtp-server "smtp.gmail.com")
    (smtpmail-smtp-service 587)
    (smtpmail-stream-type 'starttls)
    (mail-user-agent 'mu4e-user-agent)
    :bind (("C-x M-u" . mu4e)
           ("C-c C-a" . mu4e-view-attachment-action)))

  (defun attach-marked-files (buffer)
    "Attach all marked files to BUFFER"
    (interactive "BAttach to buffer: ")
    (let ((files (dired-get-marked-files)))
      (with-current-buffer (get-buffer buffer)
        (dolist (file files)
          (if (file-regular-p file)
              (mml-attach-file file
                               (mm-default-file-encoding file)
                               nil "attachment")
            (message "skipping non-regular file %s" file)))))
    (switch-to-buffer buffer))
#+END_SRC
** COMMENT telega
#+BEGIN_SRC emacs-lisp

  (defun disable-company-mode ()
    (company-mode -1))

  (use-package telega
    :bind (("C-x M-t" . telega))
    :hook ((telega-chat-mode . disable-company-mode))
    :custom
    (telega-video-player-command "mpv")
    :config
    (telega-notifications-mode t)
    (telega-mode-line-mode t)
    (setcdr (assq t org-file-apps-gnu) 'browse-url-xdg-open)
    (setq telega-open-file-function 'org-open-file)
    (setq telega-open-message-as-file '(animation photo video video-note))
    (setq-default
     org-file-apps
     '((auto-mode . emacs)
       (directory . emacs)
       ("\\.mm\\'" . default)
       ("\\.jpg\\'" . default)
       ("\\.png\\'" . default)
       ("\\.gif\\'" . default)
       ("\\.x?html?\\'" . default)
       ("\\.pdf\\'" . default)))
    )
#+END_SRC
** markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq-default markdown-open-command "multimarkdown"))
#+END_SRC

** direnv
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :bind (("C-z M-d" . direnv-allow))
    :custom
    (direnv-always-show-summary t)
    :config
    (direnv-mode))

#+END_SRC

* Prog modes
** lsp
   #+begin_src emacs-lisp
     (use-package lsp-ui)

     (use-package lsp-mode
       :hook ((lsp-mode . lsp-ui-mode)
              (lsp-mode . lsp-enable-which-key-integration))
       :commands (lsp lsp-register-custom-settings lsp-deferred)
       ;; reformat code and add missing (or remove old) imports
       :custom
       (lsp-keymap-prefix "C-c l")
       (lsp-prefer-flymake nil)
       (read-process-output-max 8092)
       (gc-cons-threshold 1800000)
       :config
       (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
       (add-to-list 'lsp-language-id-configuration '(nix-mode . "nix"))
       (lsp-register-client
        (make-lsp-client :new-connection (lsp-stdio-connection '("rnix-lsp"))
                         :major-modes '(nix-mode)
                         :server-id 'nix))
       :init
       (add-to-list 'exec-path "/home/zarkone/.emacs.d/elixir-ls")
       (add-hook 'lsp-mode-hook
                 ;; TODO: add macro or fn for `when find minor-mode ...`
                 #'(lambda ()
                     (when (member 'lsp-mode minor-mode-list)
                       (lsp-format-buffer)
                       (lsp-organize-imports))))

       :bind (("C-c d" . lsp-describe-thing-at-point)
              ("C-c e n" . flymake-goto-next-error)
              ("C-c e p" . flymake-goto-prev-error)
              ("C-c e r" . lsp-find-references)
              ("C-c e R" . lsp-rename)
              ("C-c e i" . lsp-find-implementation)
              ("C-c e t" . lsp-find-type-definition)))
   #+end_src

** Rust
#+BEGIN_SRC emacs-lisp
  (use-package cargo)
  (use-package flycheck-rust)
  (use-package rust-mode
    :hook ((flycheck-mode . flycheck-rust-setup)
           (rust-mode . lsp)
           (rust-mode . cargo-minor-mode)
           (rust-mode . flycheck-mode))
    :custom
    (indent-tabs-mode nil)
    (rust-format-on-save t)
    (compile-command "cargo build")
    :bind (:map rust-mode-map
                ("C-c C-m" . rust-run)
                ("C-j" . newline)
                ("C-c C-t" . rust-test)
                ("TAB" . company-indent-or-complete-common)))
#+END_SRC
** Clojure
   #+begin_src emacs-lisp
     (defun cider-save-and-compile-and-load-file ()
       "Save file, then compile and load it"
       (interactive)
       (save-buffer)
       (call-interactively 'cider-load-buffer))

     ;; (use-package rainbow-mode)

     (use-package cider
       :commands (cider-mode)
       :hook ((cider-mode . eldoc-mode))
       :init
       (setq cider-known-endpoints '(("pitch-app/desktop-app" "localhost" "7888")))

       :bind (:map cider-mode-map
                   ("C-c C-k" . cider-save-and-compile-and-load-file)
                   ("C-c C-i" . cider-interrupt)
                   :map cider-repl-mode-map
                   ("C-c C-l" . cider-repl-clear-buffer)
                   ))

     (use-package flycheck-clj-kondo)

     (use-package clj-refactor
       :commands (clj-refactor-mode)
       :config
       (cljr-add-keybindings-with-prefix "C-c C-j"))

     (use-package clojure-mode

       :hook (
              ;; requires clojure-lsp
              ;; (clojure-mode . lsp)
              (clojure-mode . cider-mode)
              ;; (clojure-mode . rainbow-delimiters-mode)
              (clojure-mode . enable-paredit-mode)
              (clojure-mode . flycheck-mode)
              (clojure-mode . clj-refactor-mode))
       :config
       (require 'flycheck-clj-kondo))
   #+end_src
** ts
*** with lsp
#+begin_src emacs-lisp
  (use-package typescript-mode
    :custom
    (typescript-indent-level 2)
    (flycheck-check-syntax-automatically '(save mode-enabled))
    :hook ((typescript-mode . lsp)
           (typescript-mode . flycheck-mode)))
#+end_src

** js
   #+begin_src emacs-lisp
     (use-package js-mode
       :custom
       (js-indent-level 2)
       :ensure nil)
   #+end_src

** haskell
  #+begin_src emacs-lisp
    (use-package haskell-mode)
  #+end_src
